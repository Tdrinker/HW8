#    calc40.ums
#
#    Purpose: contains calculator-related functions.
#
#    By: Ge Gao, Ari Brown
#
#    Treat r3 as the number of numbers(values) on the stack
#    Treat r4 as the boolean value: 0 if in waiting state
#                                   1 if in entering state
#
#    Before pushing a value(of a digit) to the value stack, we  
#	 convert it from ASCII to the corresponding decimal number
#    in the ASCII table

	.zero r0
	.temps r6, r7
	.section rodata
	// temp_stk:
	// .space 100000
	jumptable:
	.space 256

//************************* initialize the jump table ************************//
	.section init
init_table:
	push r1 on stack r2
	output "start initializing jumptable\n"
	push r3 on stack r2               // saves non-volatile pointer r3
	push r4 on stack r2               // saves non-volatile pointer r4
	r3 := 0                           // r3 holds the current table index
	output "continue initializing jumptable\n"

init_table_loop:
	r4 := jumptable + r3              // r4 holds the position in the table
	m[r0][r4] := input_error          // initialize current bucket to error
	r3 := r3 + 1                      // update current table index
	r5 := 256 - r3                    // keep initializing while not at 
	if (r5 != 0) goto init_table_loop // the end of the table

	pop r4 off stack r2               // restore r4
	pop r3 off stack r2               // restore r3
	pop r1 off stack r2

//***************** Commands Specifications and Initializations **************//
	.section init
init_commands:
	m[r0][jumptable + '0'] := digit   // initialize digits in jumptable
	m[r0][jumptable + '1'] := digit  
	m[r0][jumptable + '2'] := digit   
	m[r0][jumptable + '3'] := digit   
	m[r0][jumptable + '4'] := digit   
	m[r0][jumptable + '5'] := digit   
	m[r0][jumptable + '6'] := digit   
	m[r0][jumptable + '7'] := digit   
	m[r0][jumptable + '8'] := digit   
	m[r0][jumptable + '9'] := digit   

	m[r0][jumptable + ' '] := waiting // initialize SPACE in jumptable
	m[r0][jumptable + '*'] := mul     // initialize multiply in jumptable
	m[r0][jumptable + '+'] := add     // initialize add in jumptable
	m[r0][jumptable + '\n'] := newline// initialize newline in jumptable



//************************ calculator related macros *************************//
	.section text
main:
	r3 := 0
	goto waiting                      // start program with waiting state

input_error:
	output "invalid input character\n"   
	goto waiting                      // go back waiting state after error

waiting:
	r1 := input()                     
	r4 := 0                           // indicate in the waiting state
	goto recognize_input

recognize_input:
	r5 := jumptable + r1              // retrieve the position in the table
	r5 := m[r0][r5]						 
	goto r5                           // execute the instruction

	.temps r5,r6,r7                   // starting treat r5,r6,r7 as temps
digit:
	if (r4 == 1) goto append_digit     
	r1 := r1 - 0x30                   // convert from ASCII to decimal
	push r1 on stack r2               // push the current digit on stack  
	r3 := r3 + 1                      // number of values on the stk++
	r4 := 1                           // indicate in the entering state
	goto entering                     

entering:
	r1 := input()                     // read in the next input    
	goto recognize_input              // and examine whether it is a digit
 
append_digit:
	pop r4 off stack r2               // pop the previous digit
	r4 := r4 * 10                     // multiply the previous digit by 10
	r1 := r1 - 0x30                   // convert from ASCII to decimal	
	r1 := r1 + r4                     // successfully appended the new digit
	push r1 on stack r2               // push the appended digit on the stack
	r4 := 1                           // indicate in the entering state
	goto entering                     

mul:
	output "multiply\n"
	halt

add:
	output "add\n"
	halt

.temps r5,r6,r7
newline:
	r4 := r3

newline_loop:
	r7 := endstack - r4
	r1 := m[r0][r7]             // r1 = the current element on the value stk	
	push r1 on stack r2
	goto printd linking r1
	r4 := r4 - 1
	if (r4 != 0) goto newline_recur
	pop stack r2
	goto waiting

newline_recur:
	pop stack r2
	r7 := endstack - r4
	r1 := m[r0][r7]             // r1 = the current element on the value stk	
	push r1 on stack r2
	goto printd linking r1
	r4 := r4 - 1
	if (r4 != 0) goto newline_recur
	pop stack r2
	goto waiting
















