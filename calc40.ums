#    calc40.ums
#
#    Purpose: contains calculator-related functions.
#
#    By: Ge Gao, Ari Brown
#
#    Treat r3 as the number of numbers(values) on the stack
#    Treat r4 as the boolean value: 0 if in waiting state
#                                   1 if in entering state
#
#    Before pushing a value(of a digit) to the value stack, we  
#	 convert it from ASCII to the corresponding decimal number
#    in the ASCII table

	.zero r0
	.temps r6, r7
	.section rodata
	// temp_stk:
	// .space 100000
	jumptable:
	.space 256

//************************* initialize the jump table ************************//
	.section init
init_table:
	push r1 on stack r2
	output "start initializing jumptable\n"
	push r3 on stack r2               // saves non-volatile pointer r3
	push r4 on stack r2               // saves non-volatile pointer r4
	r3 := 0                           // r3 holds the current table index

init_table_loop:
	r4 := jumptable + r3              // r4 holds the position in the table
	m[r0][r4] := input_error          // initialize current bucket to error
	r3 := r3 + 1                      // update current table index
	r5 := 256 - r3                    // keep initializing while not at 
	if (r5 != 0) goto init_table_loop // the end of the table

	pop r4 off stack r2               // restore r4
	pop r3 off stack r2               // restore r3
	pop r1 off stack r2

//***************** Commands Specifications and Initializations **************//
	.section init
init_commands:
	m[r0][jumptable + '0'] := digit   // initialize digits in jumptable
	m[r0][jumptable + '1'] := digit  
	m[r0][jumptable + '2'] := digit   
	m[r0][jumptable + '3'] := digit   
	m[r0][jumptable + '4'] := digit   
	m[r0][jumptable + '5'] := digit   
	m[r0][jumptable + '6'] := digit   
	m[r0][jumptable + '7'] := digit   
	m[r0][jumptable + '8'] := digit   
	m[r0][jumptable + '9'] := digit   

	m[r0][jumptable + ' '] := waiting // initialize SPACE in jumptable
	m[r0][jumptable + '*'] := mul     // initialize multiply in jumptable
	m[r0][jumptable + '+'] := add     // initialize add in jumptable
	m[r0][jumptable + '-'] := sub
	m[r0][jumptable + '/'] := div
	m[r0][jumptable + 'c'] := change_sign
	m[r0][jumptable + '\n'] := newline// initialize newline in jumptable



//************************ calculator related macros *************************//
	.section text
	.zero r0 
main:
	r3 := 0
	goto waiting                      // start program with waiting state

input_error:
	output "invalid input character\n"   
	goto waiting                      // go back waiting state after error

waiting:
	r1 := input()                     
	r4 := 0                           // indicate in the waiting state
	goto recognize_input

recognize_input:
	r5 := jumptable + r1              // retrieve the position in the table
	r5 := m[r0][r5]						 
	goto r5                           // execute the instruction

	.temps r5,r6,r7                   // starting treat r5,r6,r7 as temps
digit:
	if (r4 == 1) goto append_digit     
	r1 := r1 - 0x30                   // convert from ASCII to decimal
	push r1 on stack r2               // push the current digit on stack  
	r3 := r3 + 1                      // number of values on the stk++
	r4 := 1                           // indicate in the entering state
	goto entering                     

entering:
	r1 := input()                     // read in the next input    
	goto recognize_input              // and examine whether it is a digit
 
append_digit:
	pop r4 off stack r2               // pop the previous digit
	r4 := r4 * 10                     // multiply the previous digit by 10
	r1 := r1 - 0x30                   // convert from ASCII to decimal	
	r1 := r1 + r4                     // successfully appended the new digit
	push r1 on stack r2               // push the appended digit on the stack
	r4 := 1                           // indicate in the entering state
	goto entering                     

check1:
	push r1 on stack r2
	if (r3 == 0) goto stackOverflow_one
	pop r1 off stack r2
	goto r1

check2:
    	push r1 on stack r2               // saves return address
    	if (r3 == 0) goto stackOverflow_two
	if (r3 == 1) goto stackOverflow_two

	pop r1 off stack r2               // put return address in r5
    	goto r1   

stackOverflow_two:
	output "Stack underflow - expected at least 2 elements\n"
	pop r1 off stack r2
	goto waiting

stackOverflow_one:
	output "Stack underflow - expected at least 1 element\n"
	pop r1 off stack r2
	goto waiting

change_sign:
	goto check1 linking r1

	pop r1 off stack r2
	r3 := r3 - 1

	if (r1 != 0) goto flip_sign
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

flip_sign:
	r1 := 0xFFFFFFFF - r1
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

add:
	goto check2 linking r1

	pop r1 off stack r2
	r3 := r3 - 1
	pop r4 off stack r2
	r3 := r3 - 1

	r1 := r1 + r4
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

mul:
	goto check2 linking r1
	pop r1 off stack r2
	r3 := r3 - 1
	pop r4 off stack r2
	r3 := r3 - 1

	r1 := r1 * r4
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

sub:
	goto check2 linking r1
	pop r1 off stack r2
	r3 := r3 - 1
	pop r4 off stack r2
	r3 := r3 - 1

	r1 := r4 - r1
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

div:
	goto check2 linking r1
	pop r1 off stack r2
	r3 := r3 - 1
	pop r4 off stack r2
	r3 := r3 - 1

	if (r1 == 0) goto div_by_zero

	if (r4 >s 0x7FFFFFFF) goto x_is_negative  // r4 is x
	if (r1 >s 0x7FFFFFFF) goto y_is_negative  // r1 is y

	r1 := r4 / r1
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

div_by_zero:
	output "division by 0\n"
	push r4 on stack r2
	push r1 on stack r2
	r3 := r3 + 2
	goto waiting

x_is_negative:
	output "x is negative\n"
	if (r1 >s 0x7FFFFFFF) goto x_and_y_are_negative
	r4 := 0xFFFFFFFF - r4		// x is negative, y is positive

	r1 := r4 / r1		// convert the positive division result back
	r1 := 0xFFFFFFFF - r1		// into negative representation

	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

y_is_negative:
	output "y is negative\n"
	r1 := 0xFFFFFFFF - r1		// y is negative, x is positive
				// convert the negative value into positive
	r1 := r4 / r1			// do the division
	r1 := 0xFFFFFFFF - r1		// into negative representation

	push r1 on stack r2
	r3 := r3 + 1
	goto waiting

x_and_y_are_negative:
	output "both are negative\n"
	r1 := 0xFFFFFFFF - r1

	r4 := 0xFFFFFFFF - r4

	r1 := r4 / r1
	push r1 on stack r2
	r3 := r3 + 1
	goto waiting


newline:
	if (r3 == 0) goto waiting	// don't try to print a stk of size 0
	r4 := r3

newline_loop:
	r7 := endstack - r4
	r1 := m[r0][r7]             // r1 = the current element on the value stk	
	push r1 on stack r2
	goto printd linking r1
	r4 := r4 - 1
	if (r4 != 0) goto newline_recur
	pop stack r2
	goto waiting

newline_recur:
	pop stack r2
	r7 := endstack - r4
	r1 := m[r0][r7]             // r1 = the current element on the value stk	
	push r1 on stack r2
	goto printd linking r1
	r4 := r4 - 1
	if (r4 != 0) goto newline_recur
	pop stack r2
	goto waiting





	// pop r4 off stack r2
	// r3 := r3 - 1

	// output "r4: "
	// output r4
	// output '\n'

	// pop r4 off stack r2
	// r3 := r3 - 1

	// output "r4: "
	// output r4
	// output '\n'

	// pop r4 off stack r2
	// r3 := r3 - 1

	// output "r4: "
	// output r4
	// output '\n'

	// pop r4 off stack r2
	// r3 := r3 - 1

	// output "r4: "
	// output r4
	// output '\n'




	// pop r5 off stack r2
	// r3 := r3 - 1

	// output "r5: "
	// output r5
	// output '\n'

	// pop r5 off stack r2
	// r3 := r3 - 1

	// output "r5: "
	// output r5
	// output '\n'

	// pop r5 off stack r2
	// r3 := r3 - 1

	// output "r5: "
	// output r5
	// output '\n'

	// pop r5 off stack r2
	// r3 := r3 - 1

	// output "r5: "
	// output r5
	// output '\n'



	// pop r1 off stack r2
	// r3 := r3 - 1

	// output "r1: "
	// output r1
	// output '\n'

	// pop r1 off stack r2
	// r3 := r3 - 1

	// output "r1: "
	// output r1
	// output '\n'

	// pop r1 off stack r2
	// r3 := r3 - 1

	// output "r1: "
	// output r1
	// output '\n'

	// pop r1 off stack r2
	// r3 := r3 - 1

	// output "r1: "
	// output r1
	// output '\n'






